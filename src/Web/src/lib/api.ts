//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TTXClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : { fetch };
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param search (optional) 
     * @param orderBy (optional) 
     * @param orderDir (optional) 
     * @return OK
     */
    getCreators(page?: number | undefined, limit?: number | undefined, search?: string | undefined, orderBy?: CreatorOrderBy | undefined, orderDir?: OrderDirection | undefined): Promise<CreatorPartialDtoPaginationDto> {
        let url_ = this.baseUrl + "/creators?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDir === null)
            throw new Error("The parameter 'orderDir' cannot be null.");
        else if (orderDir !== undefined)
            url_ += "orderDir=" + encodeURIComponent("" + orderDir) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreators(_response);
        });
    }

    protected processGetCreators(response: Response): Promise<CreatorPartialDtoPaginationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatorPartialDtoPaginationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorPartialDtoPaginationDto>(null as any);
    }

    /**
     * @param username (optional) 
     * @param ticker (optional) 
     * @return OK
     */
    createCreator(username?: string | undefined, ticker?: string | undefined): Promise<CreatorDto> {
        let url_ = this.baseUrl + "/creators?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (ticker === null)
            throw new Error("The parameter 'ticker' cannot be null.");
        else if (ticker !== undefined)
            url_ += "ticker=" + encodeURIComponent("" + ticker) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCreator(_response);
        });
    }

    protected processCreateCreator(response: Response): Promise<CreatorDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatorDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorDto>(null as any);
    }

    /**
     * @param step (optional) 
     * @param after (optional) 
     * @return OK
     */
    getCreator(slug: string, step?: TimeStep | undefined, after?: Date | undefined): Promise<CreatorDto> {
        let url_ = this.baseUrl + "/creators/{slug}?";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        if (step === null)
            throw new Error("The parameter 'step' cannot be null.");
        else if (step !== undefined)
            url_ += "step=" + encodeURIComponent("" + step) + "&";
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent(after ? "" + after.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreator(_response);
        });
    }

    protected processGetCreator(response: Response): Promise<CreatorDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatorDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorDto>(null as any);
    }

    /**
     * @param slug (optional) 
     * @return OK
     */
    getCreatorTransactions(creatorSlug: string, slug?: string | undefined): Promise<PlayerTransactionDto[]> {
        let url_ = this.baseUrl + "/creators/{creatorSlug}/transactions?";
        if (creatorSlug === undefined || creatorSlug === null)
            throw new Error("The parameter 'creatorSlug' must be defined.");
        url_ = url_.replace("{creatorSlug}", encodeURIComponent("" + creatorSlug));
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreatorTransactions(_response);
        });
    }

    protected processGetCreatorTransactions(response: Response): Promise<PlayerTransactionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlayerTransactionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerTransactionDto[]>(null as any);
    }

    /**
     * @return OK
     */
    creatorOptOut(creatorSlug: string): Promise<CreatorOptOutDto> {
        let url_ = this.baseUrl + "/creators/{creatorSlug}";
        if (creatorSlug === undefined || creatorSlug === null)
            throw new Error("The parameter 'creatorSlug' must be defined.");
        url_ = url_.replace("{creatorSlug}", encodeURIComponent("" + creatorSlug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatorOptOut(_response);
        });
    }

    protected processCreatorOptOut(response: Response): Promise<CreatorOptOutDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatorOptOutDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorOptOutDto>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param search (optional) 
     * @param orderBy (optional) 
     * @param orderDir (optional) 
     * @return OK
     */
    getPlayers(page?: number | undefined, limit?: number | undefined, search?: string | undefined, orderBy?: PlayerOrderBy | undefined, orderDir?: OrderDirection | undefined): Promise<PlayerDtoPaginationDto> {
        let url_ = this.baseUrl + "/players?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDir === null)
            throw new Error("The parameter 'orderDir' cannot be null.");
        else if (orderDir !== undefined)
            url_ += "orderDir=" + encodeURIComponent("" + orderDir) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlayers(_response);
        });
    }

    protected processGetPlayers(response: Response): Promise<PlayerDtoPaginationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerDtoPaginationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerDtoPaginationDto>(null as any);
    }

    /**
     * @param step (optional) 
     * @param after (optional) 
     * @return OK
     */
    getPlayer(username: string, step?: TimeStep | undefined, after?: Date | undefined): Promise<PlayerDto> {
        let url_ = this.baseUrl + "/players/{username}?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (step === null)
            throw new Error("The parameter 'step' cannot be null.");
        else if (step !== undefined)
            url_ += "step=" + encodeURIComponent("" + step) + "&";
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent(after ? "" + after.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlayer(_response);
        });
    }

    protected processGetPlayer(response: Response): Promise<PlayerDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerDto>(null as any);
    }

    /**
     * @return OK
     */
    getSelf(): Promise<PlayerDto> {
        let url_ = this.baseUrl + "/players/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSelf(_response);
        });
    }

    protected processGetSelf(response: Response): Promise<PlayerDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerDto>(null as any);
    }

    /**
     * @return OK
     */
    gamba(lootBoxId: number): Promise<LootBoxResultDto> {
        let url_ = this.baseUrl + "/players/me/lootboxes/{lootBoxId}/open";
        if (lootBoxId === undefined || lootBoxId === null)
            throw new Error("The parameter 'lootBoxId' must be defined.");
        url_ = url_.replace("{lootBoxId}", encodeURIComponent("" + lootBoxId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGamba(_response);
        });
    }

    protected processGamba(response: Response): Promise<LootBoxResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LootBoxResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LootBoxResultDto>(null as any);
    }

    /**
     * @param code (optional) 
     * @return OK
     */
    twitchCallback(code?: string | undefined): Promise<TokenDto> {
        let url_ = this.baseUrl + "/sessions/twitch/callback?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTwitchCallback(_response);
        });
    }

    protected processTwitchCallback(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(null as any);
    }

    /**
     * @param code (optional) 
     * @return OK
     */
    discordCallback(code?: string | undefined): Promise<DiscordTokenDto> {
        let url_ = this.baseUrl + "/sessions/discord/callback?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDiscordCallback(_response);
        });
    }

    protected processDiscordCallback(response: Response): Promise<DiscordTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscordTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiscordTokenDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    linkDiscordTwitch(body?: LinkDiscordTwitchDto | undefined): Promise<TokenDto> {
        let url_ = this.baseUrl + "/sessions/discord/link";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLinkDiscordTwitch(_response);
        });
    }

    protected processLinkDiscordTwitch(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    placeOrder(body?: CreateTransactionDto | undefined): Promise<CreatorTransactionDto> {
        let url_ = this.baseUrl + "/transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlaceOrder(_response);
        });
    }

    protected processPlaceOrder(response: Response): Promise<CreatorTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatorTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorTransactionDto>(null as any);
    }
}

export class CreateTransactionDto implements ICreateTransactionDto {
    creator!: string;
    action!: TransactionAction;
    amount!: number;

    constructor(data?: ICreateTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creator = _data["creator"] !== undefined ? _data["creator"] : <any>null;
            this.action = _data["action"] !== undefined ? _data["action"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): CreateTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creator"] = this.creator !== undefined ? this.creator : <any>null;
        data["action"] = this.action !== undefined ? this.action : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export interface ICreateTransactionDto {
    creator: string;
    action: TransactionAction;
    amount: number;
}

export class CreatorDto implements ICreatorDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    name!: string;
    slug!: string;
    twitch_id!: string;
    readonly url!: string;
    avatar_url!: string;
    ticker!: string;
    value!: number;
    stream_status!: StreamStatusDto;
    history!: VoteDto[];
    transactions!: CreatorTransactionDto[];
    shares!: CreatorShareDto[];

    constructor(data?: ICreatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.stream_status = new StreamStatusDto();
            this.history = [];
            this.transactions = [];
            this.shares = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.twitch_id = _data["twitch_id"] !== undefined ? _data["twitch_id"] : <any>null;
            (<any>this).url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.avatar_url = _data["avatar_url"] !== undefined ? _data["avatar_url"] : <any>null;
            this.ticker = _data["ticker"] !== undefined ? _data["ticker"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.stream_status = _data["stream_status"] ? StreamStatusDto.fromJS(_data["stream_status"]) : new StreamStatusDto();
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(VoteDto.fromJS(item));
            }
            else {
                this.history = <any>null;
            }
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(CreatorTransactionDto.fromJS(item));
            }
            else {
                this.transactions = <any>null;
            }
            if (Array.isArray(_data["shares"])) {
                this.shares = [] as any;
                for (let item of _data["shares"])
                    this.shares!.push(CreatorShareDto.fromJS(item));
            }
            else {
                this.shares = <any>null;
            }
        }
    }

    static fromJS(data: any): CreatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["twitch_id"] = this.twitch_id !== undefined ? this.twitch_id : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["avatar_url"] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
        data["ticker"] = this.ticker !== undefined ? this.ticker : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["stream_status"] = this.stream_status ? this.stream_status.toJSON() : <any>null;
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        if (Array.isArray(this.shares)) {
            data["shares"] = [];
            for (let item of this.shares)
                data["shares"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatorDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    name: string;
    slug: string;
    twitch_id: string;
    url: string;
    avatar_url: string;
    ticker: string;
    value: number;
    stream_status: StreamStatusDto;
    history: VoteDto[];
    transactions: CreatorTransactionDto[];
    shares: CreatorShareDto[];
}

export class CreatorOptOutDto implements ICreatorOptOutDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    twitch_id!: string;

    constructor(data?: ICreatorOptOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.twitch_id = _data["twitch_id"] !== undefined ? _data["twitch_id"] : <any>null;
        }
    }

    static fromJS(data: any): CreatorOptOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatorOptOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["twitch_id"] = this.twitch_id !== undefined ? this.twitch_id : <any>null;
        return data;
    }
}

export interface ICreatorOptOutDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    twitch_id: string;
}

export enum CreatorOrderBy {
    Name = "Name",
    Value = "Value",
    IsLive = "IsLive",
}

export class CreatorPartialDto implements ICreatorPartialDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    name!: string;
    slug!: string;
    twitch_id!: string;
    readonly url!: string;
    avatar_url!: string;
    ticker!: string;
    value!: number;
    stream_status!: StreamStatusDto;
    history!: VoteDto[];

    constructor(data?: ICreatorPartialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.stream_status = new StreamStatusDto();
            this.history = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.twitch_id = _data["twitch_id"] !== undefined ? _data["twitch_id"] : <any>null;
            (<any>this).url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.avatar_url = _data["avatar_url"] !== undefined ? _data["avatar_url"] : <any>null;
            this.ticker = _data["ticker"] !== undefined ? _data["ticker"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.stream_status = _data["stream_status"] ? StreamStatusDto.fromJS(_data["stream_status"]) : new StreamStatusDto();
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(VoteDto.fromJS(item));
            }
            else {
                this.history = <any>null;
            }
        }
    }

    static fromJS(data: any): CreatorPartialDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatorPartialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["twitch_id"] = this.twitch_id !== undefined ? this.twitch_id : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["avatar_url"] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
        data["ticker"] = this.ticker !== undefined ? this.ticker : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["stream_status"] = this.stream_status ? this.stream_status.toJSON() : <any>null;
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatorPartialDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    name: string;
    slug: string;
    twitch_id: string;
    url: string;
    avatar_url: string;
    ticker: string;
    value: number;
    stream_status: StreamStatusDto;
    history: VoteDto[];
}

export class CreatorPartialDtoPaginationDto implements ICreatorPartialDtoPaginationDto {
    data!: CreatorPartialDto[];
    total!: number;

    constructor(data?: ICreatorPartialDtoPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CreatorPartialDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
        }
    }

    static fromJS(data: any): CreatorPartialDtoPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatorPartialDtoPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data;
    }
}

export interface ICreatorPartialDtoPaginationDto {
    data: CreatorPartialDto[];
    total: number;
}

export class CreatorRarityDto implements ICreatorRarityDto {
    creator!: CreatorPartialDto;
    rarity!: Rarity;

    constructor(data?: ICreatorRarityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.creator = new CreatorPartialDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creator = _data["creator"] ? CreatorPartialDto.fromJS(_data["creator"]) : new CreatorPartialDto();
            this.rarity = _data["rarity"] !== undefined ? _data["rarity"] : <any>null;
        }
    }

    static fromJS(data: any): CreatorRarityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatorRarityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creator"] = this.creator ? this.creator.toJSON() : <any>null;
        data["rarity"] = this.rarity !== undefined ? this.rarity : <any>null;
        return data;
    }
}

export interface ICreatorRarityDto {
    creator: CreatorPartialDto;
    rarity: Rarity;
}

export class CreatorShareDto implements ICreatorShareDto {
    player!: PlayerPartialDto;
    quantity!: number;

    constructor(data?: ICreatorShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.player = new PlayerPartialDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.player = _data["player"] ? PlayerPartialDto.fromJS(_data["player"]) : new PlayerPartialDto();
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
        }
    }

    static fromJS(data: any): CreatorShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatorShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["player"] = this.player ? this.player.toJSON() : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        return data;
    }
}

export interface ICreatorShareDto {
    player: PlayerPartialDto;
    quantity: number;
}

export class CreatorTransactionDto implements ICreatorTransactionDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    quantity!: number;
    value!: number;
    action!: TransactionAction;
    creator_id!: number;
    player_id!: number;
    player!: PlayerPartialDto;

    constructor(data?: ICreatorTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.player = new PlayerPartialDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.action = _data["action"] !== undefined ? _data["action"] : <any>null;
            this.creator_id = _data["creator_id"] !== undefined ? _data["creator_id"] : <any>null;
            this.player_id = _data["player_id"] !== undefined ? _data["player_id"] : <any>null;
            this.player = _data["player"] ? PlayerPartialDto.fromJS(_data["player"]) : new PlayerPartialDto();
        }
    }

    static fromJS(data: any): CreatorTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatorTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["action"] = this.action !== undefined ? this.action : <any>null;
        data["creator_id"] = this.creator_id !== undefined ? this.creator_id : <any>null;
        data["player_id"] = this.player_id !== undefined ? this.player_id : <any>null;
        data["player"] = this.player ? this.player.toJSON() : <any>null;
        return data;
    }
}

export interface ICreatorTransactionDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    quantity: number;
    value: number;
    action: TransactionAction;
    creator_id: number;
    player_id: number;
    player: PlayerPartialDto;
}

export class DiscordTokenDto implements IDiscordTokenDto {
    access_token!: string;
    link_token!: string;
    readonly twitch_users!: TwitchUserDto[];

    constructor(data?: IDiscordTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.twitch_users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"] !== undefined ? _data["access_token"] : <any>null;
            this.link_token = _data["link_token"] !== undefined ? _data["link_token"] : <any>null;
            if (Array.isArray(_data["twitch_users"])) {
                (<any>this).twitch_users = [] as any;
                for (let item of _data["twitch_users"])
                    (<any>this).twitch_users!.push(TwitchUserDto.fromJS(item));
            }
            else {
                (<any>this).twitch_users = <any>null;
            }
        }
    }

    static fromJS(data: any): DiscordTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscordTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token !== undefined ? this.access_token : <any>null;
        data["link_token"] = this.link_token !== undefined ? this.link_token : <any>null;
        if (Array.isArray(this.twitch_users)) {
            data["twitch_users"] = [];
            for (let item of this.twitch_users)
                data["twitch_users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDiscordTokenDto {
    access_token: string;
    link_token: string;
    twitch_users: TwitchUserDto[];
}

export class LinkDiscordTwitchDto implements ILinkDiscordTwitchDto {
    access_token!: string;
    twitch_id!: string;

    constructor(data?: ILinkDiscordTwitchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"] !== undefined ? _data["access_token"] : <any>null;
            this.twitch_id = _data["twitch_id"] !== undefined ? _data["twitch_id"] : <any>null;
        }
    }

    static fromJS(data: any): LinkDiscordTwitchDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkDiscordTwitchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token !== undefined ? this.access_token : <any>null;
        data["twitch_id"] = this.twitch_id !== undefined ? this.twitch_id : <any>null;
        return data;
    }
}

export interface ILinkDiscordTwitchDto {
    access_token: string;
    twitch_id: string;
}

export class LootBoxDto implements ILootBoxDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    is_open!: boolean;
    result!: CreatorPartialDto;
    player!: PlayerPartialDto;

    constructor(data?: ILootBoxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new CreatorPartialDto();
            this.player = new PlayerPartialDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.is_open = _data["is_open"] !== undefined ? _data["is_open"] : <any>null;
            this.result = _data["result"] ? CreatorPartialDto.fromJS(_data["result"]) : new CreatorPartialDto();
            this.player = _data["player"] ? PlayerPartialDto.fromJS(_data["player"]) : new PlayerPartialDto();
        }
    }

    static fromJS(data: any): LootBoxDto {
        data = typeof data === 'object' ? data : {};
        let result = new LootBoxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["is_open"] = this.is_open !== undefined ? this.is_open : <any>null;
        data["result"] = this.result ? this.result.toJSON() : <any>null;
        data["player"] = this.player ? this.player.toJSON() : <any>null;
        return data;
    }
}

export interface ILootBoxDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    is_open: boolean;
    result: CreatorPartialDto;
    player: PlayerPartialDto;
}

export class LootBoxResultDto implements ILootBoxResultDto {
    lootbox_id!: ModelId;
    player!: PlayerPartialDto;
    result!: CreatorRarityDto;
    rarities!: CreatorRarityDto[];

    constructor(data?: ILootBoxResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lootbox_id = new ModelId();
            this.player = new PlayerPartialDto();
            this.result = new CreatorRarityDto();
            this.rarities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lootbox_id = _data["lootbox_id"] ? ModelId.fromJS(_data["lootbox_id"]) : new ModelId();
            this.player = _data["player"] ? PlayerPartialDto.fromJS(_data["player"]) : new PlayerPartialDto();
            this.result = _data["result"] ? CreatorRarityDto.fromJS(_data["result"]) : new CreatorRarityDto();
            if (Array.isArray(_data["rarities"])) {
                this.rarities = [] as any;
                for (let item of _data["rarities"])
                    this.rarities!.push(CreatorRarityDto.fromJS(item));
            }
            else {
                this.rarities = <any>null;
            }
        }
    }

    static fromJS(data: any): LootBoxResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LootBoxResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lootbox_id"] = this.lootbox_id ? this.lootbox_id.toJSON() : <any>null;
        data["player"] = this.player ? this.player.toJSON() : <any>null;
        data["result"] = this.result ? this.result.toJSON() : <any>null;
        if (Array.isArray(this.rarities)) {
            data["rarities"] = [];
            for (let item of this.rarities)
                data["rarities"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILootBoxResultDto {
    lootbox_id: ModelId;
    player: PlayerPartialDto;
    result: CreatorRarityDto;
    rarities: CreatorRarityDto[];
}

export class ModelId implements IModelId {
    value!: number;

    constructor(data?: IModelId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): ModelId {
        data = typeof data === 'object' ? data : {};
        let result = new ModelId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IModelId {
    value: number;
}

export enum OrderDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class PlayerDto implements IPlayerDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    name!: string;
    slug!: string;
    twitch_id!: string;
    readonly url!: string;
    avatar_url!: string;
    credits!: number;
    portfolio!: number;
    value!: number;
    type!: PlayerType;
    transactions!: PlayerTransactionDto[];
    loot_boxes!: LootBoxDto[];
    shares!: PlayerShareDto[];
    history!: PortfolioSnapshotDto[];

    constructor(data?: IPlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.transactions = [];
            this.loot_boxes = [];
            this.shares = [];
            this.history = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.twitch_id = _data["twitch_id"] !== undefined ? _data["twitch_id"] : <any>null;
            (<any>this).url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.avatar_url = _data["avatar_url"] !== undefined ? _data["avatar_url"] : <any>null;
            this.credits = _data["credits"] !== undefined ? _data["credits"] : <any>null;
            this.portfolio = _data["portfolio"] !== undefined ? _data["portfolio"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(PlayerTransactionDto.fromJS(item));
            }
            else {
                this.transactions = <any>null;
            }
            if (Array.isArray(_data["loot_boxes"])) {
                this.loot_boxes = [] as any;
                for (let item of _data["loot_boxes"])
                    this.loot_boxes!.push(LootBoxDto.fromJS(item));
            }
            else {
                this.loot_boxes = <any>null;
            }
            if (Array.isArray(_data["shares"])) {
                this.shares = [] as any;
                for (let item of _data["shares"])
                    this.shares!.push(PlayerShareDto.fromJS(item));
            }
            else {
                this.shares = <any>null;
            }
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(PortfolioSnapshotDto.fromJS(item));
            }
            else {
                this.history = <any>null;
            }
        }
    }

    static fromJS(data: any): PlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["twitch_id"] = this.twitch_id !== undefined ? this.twitch_id : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["avatar_url"] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
        data["credits"] = this.credits !== undefined ? this.credits : <any>null;
        data["portfolio"] = this.portfolio !== undefined ? this.portfolio : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        if (Array.isArray(this.loot_boxes)) {
            data["loot_boxes"] = [];
            for (let item of this.loot_boxes)
                data["loot_boxes"].push(item.toJSON());
        }
        if (Array.isArray(this.shares)) {
            data["shares"] = [];
            for (let item of this.shares)
                data["shares"].push(item.toJSON());
        }
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPlayerDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    name: string;
    slug: string;
    twitch_id: string;
    url: string;
    avatar_url: string;
    credits: number;
    portfolio: number;
    value: number;
    type: PlayerType;
    transactions: PlayerTransactionDto[];
    loot_boxes: LootBoxDto[];
    shares: PlayerShareDto[];
    history: PortfolioSnapshotDto[];
}

export class PlayerDtoPaginationDto implements IPlayerDtoPaginationDto {
    data!: PlayerDto[];
    total!: number;

    constructor(data?: IPlayerDtoPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PlayerDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
        }
    }

    static fromJS(data: any): PlayerDtoPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerDtoPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data;
    }
}

export interface IPlayerDtoPaginationDto {
    data: PlayerDto[];
    total: number;
}

export enum PlayerOrderBy {
    Name = "Name",
    Credits = "Credits",
    Portfolio = "Portfolio",
}

export class PlayerPartialDto implements IPlayerPartialDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    name!: string;
    slug!: string;
    twitch_id!: string;
    readonly url!: string;
    avatar_url!: string;
    credits!: number;
    portfolio!: number;
    value!: number;
    type!: PlayerType;

    constructor(data?: IPlayerPartialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.twitch_id = _data["twitch_id"] !== undefined ? _data["twitch_id"] : <any>null;
            (<any>this).url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.avatar_url = _data["avatar_url"] !== undefined ? _data["avatar_url"] : <any>null;
            this.credits = _data["credits"] !== undefined ? _data["credits"] : <any>null;
            this.portfolio = _data["portfolio"] !== undefined ? _data["portfolio"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PlayerPartialDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerPartialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["twitch_id"] = this.twitch_id !== undefined ? this.twitch_id : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["avatar_url"] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
        data["credits"] = this.credits !== undefined ? this.credits : <any>null;
        data["portfolio"] = this.portfolio !== undefined ? this.portfolio : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }
}

export interface IPlayerPartialDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    name: string;
    slug: string;
    twitch_id: string;
    url: string;
    avatar_url: string;
    credits: number;
    portfolio: number;
    value: number;
    type: PlayerType;
}

export class PlayerShareDto implements IPlayerShareDto {
    creator!: CreatorPartialDto;
    quantity!: number;

    constructor(data?: IPlayerShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.creator = new CreatorPartialDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creator = _data["creator"] ? CreatorPartialDto.fromJS(_data["creator"]) : new CreatorPartialDto();
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
        }
    }

    static fromJS(data: any): PlayerShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creator"] = this.creator ? this.creator.toJSON() : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        return data;
    }
}

export interface IPlayerShareDto {
    creator: CreatorPartialDto;
    quantity: number;
}

export class PlayerTransactionDto implements IPlayerTransactionDto {
    id!: number;
    created_at!: Date;
    updated_at!: Date;
    quantity!: number;
    value!: number;
    action!: TransactionAction;
    creator_id!: number;
    player_id!: number;
    creator!: CreatorPartialDto;

    constructor(data?: IPlayerTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.creator = new CreatorPartialDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>null;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.action = _data["action"] !== undefined ? _data["action"] : <any>null;
            this.creator_id = _data["creator_id"] !== undefined ? _data["creator_id"] : <any>null;
            this.player_id = _data["player_id"] !== undefined ? _data["player_id"] : <any>null;
            this.creator = _data["creator"] ? CreatorPartialDto.fromJS(_data["creator"]) : new CreatorPartialDto();
        }
    }

    static fromJS(data: any): PlayerTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>null;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["action"] = this.action !== undefined ? this.action : <any>null;
        data["creator_id"] = this.creator_id !== undefined ? this.creator_id : <any>null;
        data["player_id"] = this.player_id !== undefined ? this.player_id : <any>null;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>null;
        return data;
    }
}

export interface IPlayerTransactionDto {
    id: number;
    created_at: Date;
    updated_at: Date;
    quantity: number;
    value: number;
    action: TransactionAction;
    creator_id: number;
    player_id: number;
    creator: CreatorPartialDto;
}

export enum PlayerType {
    User = "User",
    Admin = "Admin",
}

export class PortfolioSnapshotDto implements IPortfolioSnapshotDto {
    player_id!: number;
    value!: number;
    time!: Date;

    constructor(data?: IPortfolioSnapshotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.player_id = _data["player_id"] !== undefined ? _data["player_id"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PortfolioSnapshotDto {
        data = typeof data === 'object' ? data : {};
        let result = new PortfolioSnapshotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["player_id"] = this.player_id !== undefined ? this.player_id : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        return data;
    }
}

export interface IPortfolioSnapshotDto {
    player_id: number;
    value: number;
    time: Date;
}

export enum Rarity {
    Pennies = "Pennies",
    Common = "Common",
    Rare = "Rare",
    Epic = "Epic",
}

export class StreamStatusDto implements IStreamStatusDto {
    is_live!: boolean;
    started_at?: Date | null;
    ended_at?: Date | null;

    constructor(data?: IStreamStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_live = _data["is_live"] !== undefined ? _data["is_live"] : <any>null;
            this.started_at = _data["started_at"] ? new Date(_data["started_at"].toString()) : <any>null;
            this.ended_at = _data["ended_at"] ? new Date(_data["ended_at"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): StreamStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new StreamStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_live"] = this.is_live !== undefined ? this.is_live : <any>null;
        data["started_at"] = this.started_at ? this.started_at.toISOString() : <any>null;
        data["ended_at"] = this.ended_at ? this.ended_at.toISOString() : <any>null;
        return data;
    }
}

export interface IStreamStatusDto {
    is_live: boolean;
    started_at?: Date | null;
    ended_at?: Date | null;
}

export enum TimeStep {
    Minute = "Minute",
    FiveMinute = "FiveMinute",
    FifteenMinute = "FifteenMinute",
    ThirtyMinute = "ThirtyMinute",
    Hour = "Hour",
    Day = "Day",
    Week = "Week",
    Month = "Month",
}

export class TokenDto implements ITokenDto {
    access_token!: string;

    constructor(data?: ITokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"] !== undefined ? _data["access_token"] : <any>null;
        }
    }

    static fromJS(data: any): TokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token !== undefined ? this.access_token : <any>null;
        return data;
    }
}

export interface ITokenDto {
    access_token: string;
}

export enum TransactionAction {
    Buy = "Buy",
    Sell = "Sell",
    Open = "Open",
}

export class TwitchUserDto implements ITwitchUserDto {
    id!: string;
    display_name!: string;
    login!: string;
    avatar_url!: string;

    constructor(data?: ITwitchUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.display_name = _data["display_name"] !== undefined ? _data["display_name"] : <any>null;
            this.login = _data["login"] !== undefined ? _data["login"] : <any>null;
            this.avatar_url = _data["avatar_url"] !== undefined ? _data["avatar_url"] : <any>null;
        }
    }

    static fromJS(data: any): TwitchUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwitchUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["display_name"] = this.display_name !== undefined ? this.display_name : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["avatar_url"] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
        return data;
    }
}

export interface ITwitchUserDto {
    id: string;
    display_name: string;
    login: string;
    avatar_url: string;
}

export class VoteDto implements IVoteDto {
    creator_id!: number;
    value!: number;
    time!: Date;

    constructor(data?: IVoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creator_id = _data["creator_id"] !== undefined ? _data["creator_id"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): VoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creator_id"] = this.creator_id !== undefined ? this.creator_id : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        return data;
    }
}

export interface IVoteDto {
    creator_id: number;
    value: number;
    time: Date;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
