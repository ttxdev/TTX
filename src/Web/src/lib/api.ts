//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TTXClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param search (optional) 
     * @param orderBy (optional) 
     * @param orderDir (optional) 
     * @return OK
     */
    getCreators(page?: number | undefined, limit?: number | undefined, search?: string | undefined, orderBy?: CreatorOrderBy | undefined, orderDir?: OrderDirection | undefined): Promise<CreatorPartialDtoPaginationDto> {
        let url_ = this.baseUrl + "/creators?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDir === null)
            throw new Error("The parameter 'orderDir' cannot be null.");
        else if (orderDir !== undefined)
            url_ += "orderDir=" + encodeURIComponent("" + orderDir) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreators(_response);
        });
    }

    protected processGetCreators(response: Response): Promise<CreatorPartialDtoPaginationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreatorPartialDtoPaginationDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorPartialDtoPaginationDto>(null as any);
    }

    /**
     * @param username (optional) 
     * @return OK
     */
    createCreator(value: string, username?: string | undefined): Promise<CreatorDto> {
        let url_ = this.baseUrl + "/creators?";
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined and cannot be null.");
        else
            url_ += "Value=" + encodeURIComponent("" + value) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCreator(_response);
        });
    }

    protected processCreateCreator(response: Response): Promise<CreatorDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreatorDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorDto>(null as any);
    }

    /**
     * @param step (optional) 
     * @param after (optional) 
     * @return OK
     */
    getCreator(slug: string, step?: TimeStep | undefined, after?: Date | undefined): Promise<CreatorDto> {
        let url_ = this.baseUrl + "/creators/{slug}?";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        if (step === null)
            throw new Error("The parameter 'step' cannot be null.");
        else if (step !== undefined)
            url_ += "step=" + encodeURIComponent("" + step) + "&";
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent(after ? "" + after.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreator(_response);
        });
    }

    protected processGetCreator(response: Response): Promise<CreatorDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreatorDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorDto>(null as any);
    }

    /**
     * @param after (optional) 
     * @param step (optional) 
     * @return OK
     */
    getLatestCreatorValue(creatorSlug: string, after?: Date | undefined, step?: TimeStep | undefined): Promise<Vote[]> {
        let url_ = this.baseUrl + "/creators/{creatorSlug}/value/latest?";
        if (creatorSlug === undefined || creatorSlug === null)
            throw new Error("The parameter 'creatorSlug' must be defined.");
        url_ = url_.replace("{creatorSlug}", encodeURIComponent("" + creatorSlug));
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent(after ? "" + after.toISOString() : "") + "&";
        if (step === null)
            throw new Error("The parameter 'step' cannot be null.");
        else if (step !== undefined)
            url_ += "step=" + encodeURIComponent("" + step) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLatestCreatorValue(_response);
        });
    }

    protected processGetLatestCreatorValue(response: Response): Promise<Vote[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Vote[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vote[]>(null as any);
    }

    /**
     * @param slug (optional) 
     * @return OK
     */
    getCreatorTransactions(creatorSlug: string, slug?: string | undefined): Promise<PlayerTransactionDto[]> {
        let url_ = this.baseUrl + "/creators/{creatorSlug}/transactions?";
        if (creatorSlug === undefined || creatorSlug === null)
            throw new Error("The parameter 'creatorSlug' must be defined.");
        url_ = url_.replace("{creatorSlug}", encodeURIComponent("" + creatorSlug));
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreatorTransactions(_response);
        });
    }

    protected processGetCreatorTransactions(response: Response): Promise<PlayerTransactionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlayerTransactionDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerTransactionDto[]>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @param search (optional) 
     * @param orderBy (optional) 
     * @param orderDir (optional) 
     * @return OK
     */
    getPlayers(page?: number | undefined, limit?: number | undefined, search?: string | undefined, orderBy?: PlayerOrderBy | undefined, orderDir?: OrderDirection | undefined): Promise<PlayerDtoPaginationDto> {
        let url_ = this.baseUrl + "/players?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDir === null)
            throw new Error("The parameter 'orderDir' cannot be null.");
        else if (orderDir !== undefined)
            url_ += "orderDir=" + encodeURIComponent("" + orderDir) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlayers(_response);
        });
    }

    protected processGetPlayers(response: Response): Promise<PlayerDtoPaginationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlayerDtoPaginationDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerDtoPaginationDto>(null as any);
    }

    /**
     * @return OK
     */
    getPlayer(username: string): Promise<PlayerDto> {
        let url_ = this.baseUrl + "/players/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlayer(_response);
        });
    }

    protected processGetPlayer(response: Response): Promise<PlayerDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlayerDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerDto>(null as any);
    }

    /**
     * @return OK
     */
    getSelf(): Promise<PlayerDto> {
        let url_ = this.baseUrl + "/players/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSelf(_response);
        });
    }

    protected processGetSelf(response: Response): Promise<PlayerDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlayerDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerDto>(null as any);
    }

    /**
     * @return OK
     */
    gamba(lootBoxId: number): Promise<LootBoxResultDto> {
        let url_ = this.baseUrl + "/players/me/lootboxes/{lootBoxId}/open";
        if (lootBoxId === undefined || lootBoxId === null)
            throw new Error("The parameter 'lootBoxId' must be defined.");
        url_ = url_.replace("{lootBoxId}", encodeURIComponent("" + lootBoxId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGamba(_response);
        });
    }

    protected processGamba(response: Response): Promise<LootBoxResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LootBoxResultDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LootBoxResultDto>(null as any);
    }

    /**
     * @return OK
     */
    getPlayerTransactions(username: string): Promise<PlayerTransactionDto[]> {
        let url_ = this.baseUrl + "/players/{username}/transactions";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlayerTransactions(_response);
        });
    }

    protected processGetPlayerTransactions(response: Response): Promise<PlayerTransactionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlayerTransactionDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerTransactionDto[]>(null as any);
    }

    /**
     * @param code (optional) 
     * @return OK
     */
    twitchCallback(code?: string | undefined): Promise<TokenDto> {
        let url_ = this.baseUrl + "/sessions/twitch/callback?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTwitchCallback(_response);
        });
    }

    protected processTwitchCallback(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(null as any);
    }

    /**
     * @param code (optional) 
     * @return OK
     */
    discordCallback(code?: string | undefined): Promise<TokenDto> {
        let url_ = this.baseUrl + "/sessions/discord/callback?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDiscordCallback(_response);
        });
    }

    protected processDiscordCallback(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    linkDiscordTwitch(body?: LinkDiscordTwitchDto | undefined): Promise<TokenDto> {
        let url_ = this.baseUrl + "/sessions/discord/link";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLinkDiscordTwitch(_response);
        });
    }

    protected processLinkDiscordTwitch(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    placeOrder(body?: CreateTransactionDto | undefined): Promise<CreatorTransactionDto> {
        let url_ = this.baseUrl + "/transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlaceOrder(_response);
        });
    }

    protected processPlaceOrder(response: Response): Promise<CreatorTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreatorTransactionDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatorTransactionDto>(null as any);
    }
}

export interface CreateTransactionDto {
    creator: string;
    action: TransactionAction;
    amount: number;
}

export interface Creator {
    id: ModelId;
    readonly createdAt: Date;
    readonly updatedAt: Date;
    name: Name;
    slug: Slug;
    twitchId: TwitchId;
    avatarUrl: string;
    ticker: Ticker;
    value: Credits;
    streamStatus: StreamStatus;
    transactions: Transaction[];
    history: Vote[];
}

export interface CreatorDto {
    readonly id: number;
    readonly created_at: Date;
    readonly updated_at: Date;
    readonly name: string;
    readonly slug: string;
    twitch_id: TwitchId;
    readonly url: string;
    readonly avatar_url: string;
    readonly ticker: string;
    readonly value: number;
    stream_status: StreamStatusDto;
    readonly history: VoteDto[];
    readonly transactions: CreatorTransactionDto[];
    readonly shares: CreatorShareDto[];
}

export enum CreatorOrderBy {
    Name = "Name",
    Value = "Value",
    IsLive = "IsLive",
}

export interface CreatorPartialDto {
    readonly id: number;
    readonly created_at: Date;
    readonly updated_at: Date;
    readonly name: string;
    readonly slug: string;
    twitch_id: TwitchId;
    readonly url: string;
    readonly avatar_url: string;
    readonly ticker: string;
    readonly value: number;
    stream_status: StreamStatusDto;
    readonly history: VoteDto[];
}

export interface CreatorPartialDtoPaginationDto {
    data: CreatorPartialDto[];
    total: number;
}

export interface CreatorRarityDto {
    creator: CreatorPartialDto;
    rarity: Rarity;
}

export interface CreatorShareDto {
    player: PlayerPartialDto;
    readonly quantity: number;
}

export interface CreatorTransactionDto {
    readonly id: number;
    readonly created_at: Date;
    readonly updated_at: Date;
    readonly quantity: number;
    readonly value: number;
    action: TransactionAction;
    readonly creator_id: number;
    readonly player_id: number;
    player: PlayerPartialDto;
}

export interface Credits {
    value: number;
}

export interface LinkDiscordTwitchDto {
    access_token: string;
    twitch_id: string;
}

export interface LootBox {
    id: ModelId;
    readonly createdAt: Date;
    readonly updatedAt: Date;
    playerId: ModelId;
    resultId?: ModelId;
    player: Player;
    result?: Creator;
    readonly isOpen: boolean;
}

export interface LootBoxDto {
    readonly id: number;
    readonly created_at: Date;
    readonly updated_at: Date;
    readonly is_open: boolean;
    result?: CreatorPartialDto;
    player: PlayerPartialDto;
}

export interface LootBoxResultDto {
    lootbox_id: ModelId;
    player: PlayerPartialDto;
    result: CreatorRarityDto;
    readonly rarities: CreatorRarityDto[];
}

export interface ModelId {
    value: number;
}

export interface Name {
    value: string;
}

export enum OrderDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export interface Player {
    id: ModelId;
    readonly createdAt: Date;
    readonly updatedAt: Date;
    name: Name;
    slug: Slug;
    twitchId: TwitchId;
    avatarUrl: string;
    credits: Credits;
    type: PlayerType;
    transactions: Transaction[];
    lootBoxes: LootBox[];
}

export interface PlayerDto {
    readonly id: number;
    readonly created_at: Date;
    readonly updated_at: Date;
    readonly name: string;
    readonly slug: string;
    twitch_id: TwitchId;
    readonly url: string;
    readonly avatar_url: string;
    readonly credits: number;
    type: PlayerType;
    readonly transactions: PlayerTransactionDto[];
    readonly loot_boxes: LootBoxDto[];
    readonly shares: PlayerShareDto[];
}

export interface PlayerDtoPaginationDto {
    data: PlayerDto[];
    total: number;
}

export enum PlayerOrderBy {
    Name = "Name",
    Credits = "Credits",
}

export interface PlayerPartialDto {
    readonly id: number;
    readonly created_at: Date;
    readonly updated_at: Date;
    readonly name: string;
    readonly slug: string;
    twitch_id: TwitchId;
    readonly url: string;
    readonly avatar_url: string;
    readonly credits: number;
    type: PlayerType;
}

export interface PlayerShareDto {
    creator: CreatorPartialDto;
    readonly quantity: number;
}

export interface PlayerTransactionDto {
    readonly id: number;
    readonly created_at: Date;
    readonly updated_at: Date;
    readonly quantity: number;
    readonly value: number;
    action: TransactionAction;
    readonly creator_id: number;
    readonly player_id: number;
    creator: CreatorPartialDto;
}

export enum PlayerType {
    User = "User",
    Admin = "Admin",
}

export interface Quantity {
    value: number;
}

export enum Rarity {
    Pennies = "Pennies",
    Common = "Common",
    Rare = "Rare",
    Epic = "Epic",
}

export interface Slug {
    value: string;
}

export interface StreamStatus {
    readonly isLive: boolean;
    readonly startedAt?: Date | null;
    readonly endedAt?: Date | null;
}

export interface StreamStatusDto {
    readonly is_live: boolean;
    readonly started_at?: Date | null;
    readonly ended_at?: Date | null;
}

export interface Ticker {
    value: string;
}

export enum TimeStep {
    Minute = "Minute",
    FiveMinute = "FiveMinute",
    FifteenMinute = "FifteenMinute",
    ThirtyMinute = "ThirtyMinute",
    Hour = "Hour",
    Day = "Day",
    Week = "Week",
    Month = "Month",
}

export interface TokenDto {
    access_token: string;
}

export interface Transaction {
    id: ModelId;
    readonly createdAt: Date;
    readonly updatedAt: Date;
    quantity: Quantity;
    value: Credits;
    action: TransactionAction;
    creatorId: ModelId;
    playerId: ModelId;
    creator: Creator;
    player: Player;
}

export enum TransactionAction {
    Buy = "Buy",
    Sell = "Sell",
}

export interface TwitchId {
    value: string;
}

export interface Vote {
    value: Credits;
    time: Date;
    creatorId: ModelId;
    creator: Creator;
}

export interface VoteDto {
    readonly creator_id: number;
    readonly value: number;
    readonly time: Date;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}